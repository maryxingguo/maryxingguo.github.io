[{"title":"Hello World","url":"/2022/07/13/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"pycharm+pyqt5+pyinstaller实现可视化界面","url":"/2021/05/11/pycharm+pyqt5+pyinstaller%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2/","content":"<p>1、安装软件和模块pycharm+pyqt5+pyqt5-tool+pyinstaller，以及相关配置<br>2、在QT中创建界面，生成ui文件<br>注：使用帮助文档,按一次“F1”即可全屏显示帮助文档页面，按“Esc”即可退出。<br>3、通过pyuic5 -o Interface.py Interface.ui,将ui文件转为py文件。<br>4、调用，新建RecallInterface.py，以及自己主函数f1.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"comment\">#PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> PyQt5.QtWidgets <span class=\"keyword\">import</span> QApplication, QMainWindow</span><br><span class=\"line\"><span class=\"keyword\">from</span> PyQt5.QtWidgets <span class=\"keyword\">import</span> QFileDialog</span><br><span class=\"line\"><span class=\"keyword\">from</span> PyQt5.QtWidgets <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> PyQt5.QtCore <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> PyQt5.QtGui <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"comment\">#导入designer工具生成的Interface.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> XXA <span class=\"keyword\">import</span> Ui_MainWindow</span><br><span class=\"line\"><span class=\"comment\">#导入自己设计的信息函数</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> f1 <span class=\"keyword\">import</span> NewoneEVE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RecallInterface</span> (QMainWindow, Ui_MainWindow):</span><br><span class=\"line\">\t<span class=\"comment\">#初始化，定义添加信息槽</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, parent=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(RecallInterface, self).__init__(parent)</span><br><span class=\"line\">        self.ui = Ui_MainWindow()</span><br><span class=\"line\">        self.ui.setupUi(self)</span><br><span class=\"line\">        <span class=\"comment\">#初始化界面信息</span></span><br><span class=\"line\">        self.init_login_info()</span><br><span class=\"line\">        <span class=\"comment\">#触发事件</span></span><br><span class=\"line\">        self.ui.OK.clicked.connect(self.begin)</span><br><span class=\"line\">        self.ui.Reset.clicked.connect(self.clearResult)</span><br><span class=\"line\">        self.ui.openfile.clicked.connect(self.msge)</span><br><span class=\"line\">        self.url = <span class=\"string\">&quot;https://www.baidu.com/index.php?tn=monline_3_dg&quot;</span></span><br><span class=\"line\">        self.ui.pushButton.clicked.connect(self.msg)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 保存登录信息</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_login_info</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        settings = QSettings(<span class=\"string\">&quot;config.ini&quot;</span>, QSettings.IniFormat)  <span class=\"comment\"># 方法1：使用配置文件</span></span><br><span class=\"line\">        <span class=\"comment\"># settings = QSettings(&quot;mysoft&quot;,&quot;myapp&quot;)                        #方法2：使用注册表</span></span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;excelpath&quot;</span>, self.ui.excelpath.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;readsheetname&quot;</span>, self.ui.readsheetname.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;browser&quot;</span>, self.ui.browser.currentText())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;driver_path&quot;</span>, self.ui.driver_path.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;startnum&quot;</span>, self.ui.startnum.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;rownum&quot;</span>, self.ui.row.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;endnum&quot;</span>, self.ui.endnum.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;sleeptime&quot;</span>, self.ui.sleeptime.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;topage&quot;</span>, self.ui.topage.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;toline&quot;</span>, self.ui.toline.text())</span><br><span class=\"line\">        settings.setValue(<span class=\"string\">&quot;need_domain&quot;</span>, self.ui.need_domain.currentText())</span><br><span class=\"line\"><span class=\"comment\">#初始化界面信息</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">init_login_info</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        settings = QSettings(<span class=\"string\">&quot;config.ini&quot;</span>, QSettings.IniFormat)        <span class=\"comment\">#方法1：使用配置文件</span></span><br><span class=\"line\">        <span class=\"comment\">#settings = QSettings(&quot;mysoft&quot;,&quot;myapp&quot;)                        #方法2：使用注册表</span></span><br><span class=\"line\">        excelpath =settings.value(<span class=\"string\">&quot;excelpath&quot;</span>)</span><br><span class=\"line\">        readsheetname = settings.value(<span class=\"string\">&quot;readsheetname&quot;</span>)</span><br><span class=\"line\">        browser = settings.value(<span class=\"string\">&quot;browser&quot;</span>)</span><br><span class=\"line\">        driver_path = settings.value(<span class=\"string\">&quot;driver_path&quot;</span>)</span><br><span class=\"line\">        startnum = settings.value(<span class=\"string\">&quot;startnum&quot;</span>)</span><br><span class=\"line\">        endnum= settings.value(<span class=\"string\">&quot;endnum&quot;</span>)</span><br><span class=\"line\">        rownum = settings.value(<span class=\"string\">&quot;rownum&quot;</span>)</span><br><span class=\"line\">        sleeptime = settings.value(<span class=\"string\">&quot;sleeptime&quot;</span>)</span><br><span class=\"line\">        topage = settings.value(<span class=\"string\">&quot;topage&quot;</span>)</span><br><span class=\"line\">        toline = settings.value(<span class=\"string\">&quot;toline&quot;</span>)</span><br><span class=\"line\">        need_domain = settings.value(<span class=\"string\">&quot;need_domain&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">########</span></span><br><span class=\"line\">        self.ui.excelpath.setText(excelpath)</span><br><span class=\"line\">        self.ui.readsheetname.setText(readsheetname)</span><br><span class=\"line\">        self.ui.browser.setCurrentText(browser)</span><br><span class=\"line\">        self.ui.driver_path.setText(driver_path)</span><br><span class=\"line\">        self.ui.startnum.setText(startnum)</span><br><span class=\"line\">        self.ui.endnum.setText(endnum)</span><br><span class=\"line\">        self.ui.row.setText(rownum)</span><br><span class=\"line\">        self.ui.sleeptime.setText(sleeptime)</span><br><span class=\"line\">        self.ui.topage.setText(topage)</span><br><span class=\"line\">        self.ui.toline.setText(toline)</span><br><span class=\"line\">        self.ui.need_domain.setCurrentText(need_domain)</span><br><span class=\"line\">    <span class=\"comment\">#打开文件</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">msge</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"comment\"># directory1 = QFileDialog.getExistingDirectory(self,&quot;选取文件夹&quot;,&quot;./&quot;)   #起始路径</span></span><br><span class=\"line\">        fileName1, filetype1 = QFileDialog.getOpenFileName(self, <span class=\"string\">&quot;选取文件&quot;</span>, <span class=\"string\">&quot;./&quot;</span>,</span><br><span class=\"line\">                                                          <span class=\"string\">&quot;All Files (*)&quot;</span>)  <span class=\"comment\"># 设置文件扩展名过滤,注意用双分号间隔</span></span><br><span class=\"line\">        self.ui.excelpath.setText(fileName1)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">msg</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        fileName2, filetype2 = QFileDialog.getOpenFileName(self, <span class=\"string\">&quot;选取文件&quot;</span>, <span class=\"string\">&quot;./&quot;</span>,</span><br><span class=\"line\">                                                          <span class=\"string\">&quot;All Files (*)&quot;</span>)  <span class=\"comment\"># 设置文件扩展名过滤,注意用双分号间隔</span></span><br><span class=\"line\">        self.ui.driver_path.setText(fileName2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">clearResult</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.ui.excelpath.clear()</span><br><span class=\"line\">        self.ui.readsheetname.clear()</span><br><span class=\"line\">        self.ui.driver_path.clear()</span><br><span class=\"line\">        self.ui.startnum.clear()</span><br><span class=\"line\">        self.ui.endnum.clear()</span><br><span class=\"line\">        self.ui.sleeptime.clear()</span><br><span class=\"line\">        self.ui.topage.clear()</span><br><span class=\"line\">        self.ui.toline.clear()</span><br><span class=\"line\">        self.ui.output.clear()</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">begin</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    \t<span class=\"comment\">#保存配置</span></span><br><span class=\"line\">        self.save_login_info()</span><br><span class=\"line\">        startnum = <span class=\"built_in\">int</span>(self.ui.startnum.text())  </span><br><span class=\"line\">        endnum = <span class=\"built_in\">int</span>(self.ui.endnum.text()) </span><br><span class=\"line\">        rownum = <span class=\"built_in\">int</span>(self.ui.row.text())</span><br><span class=\"line\">        excelpath = self.ui.excelpath.text()</span><br><span class=\"line\">        readsheetname = self.ui.readsheetname.text() </span><br><span class=\"line\">        sleeptime = <span class=\"built_in\">int</span>(self.ui.sleeptime.text())</span><br><span class=\"line\">        browser = self.ui.browser.currentText()</span><br><span class=\"line\">        driver_path = self.ui.driver_path.text()</span><br><span class=\"line\">        topage = <span class=\"built_in\">int</span>(self.ui.topage.text())</span><br><span class=\"line\">        toline = <span class=\"built_in\">int</span>(self.ui.toline.text())</span><br><span class=\"line\">        need_domain=self.ui.need_domain.currentText()</span><br><span class=\"line\">        <span class=\"comment\"># 第3/3</span></span><br><span class=\"line\">        <span class=\"comment\">#调用主程序，New0111.py文件中NewoneEVE函数，并将返回值显示在界面上</span></span><br><span class=\"line\">        ndomin,npage,nline,mainbody=NewoneEVE(startnum, endnum, rownum, excelpath, readsheetname, sleeptime, browser,driver_path, topage, toline, need_domain)</span><br><span class=\"line\">        self.ui.output.setText(<span class=\"string\">&#x27;当前信息：&#x27;</span>+<span class=\"built_in\">str</span>(ndomin)+<span class=\"string\">&quot;  &quot;</span>+<span class=\"built_in\">str</span>(mainbody)+<span class=\"string\">&quot;  &quot;</span>+<span class=\"string\">&#x27;当前页【&#x27;</span>+ <span class=\"built_in\">str</span>(npage)+ <span class=\"string\">&#x27;】;当前行【&#x27;</span>+ <span class=\"built_in\">str</span>(nline)+ <span class=\"string\">&#x27;】&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    <span class=\"comment\">#固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class=\"line\">    app = QApplication(sys.argv)</span><br><span class=\"line\">    <span class=\"comment\">#初始化</span></span><br><span class=\"line\">    myWin = RecallInterface()</span><br><span class=\"line\">    <span class=\"comment\">#将窗口控件显示在屏幕上</span></span><br><span class=\"line\">    myWin.show()</span><br><span class=\"line\">    <span class=\"comment\">#程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class=\"line\">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>\n\n<p>5、为实验代码的可迁移性，使用命令行将文件打包生成exe文件。命令成功运行后，将会在项目目录中看到build文件夹和dist文件夹，把dist文件夹中的文件打包给第三方使用即可。<br>（1) 需要了解pyinstaller相关参数以及使用的格式<a href=\"https://pyinstaller.readthedocs.io/en/stable/index.html\">pyinstaller文档</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyinstaller -F -w RecallInterface.py</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyinstaller -F -w RecallInterface.py -i Documents.ico</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyinstaller -D RecallInterface.py Interface.py f1.py</span><br></pre></td></tr></table></figure>\n<pre><code> 常见的用法\n -F：dist文件下只有exe文件，把所有东西打包成一个exe文件，结构简单，启动慢。\n -D（默认）：dist文件下有exe文件以及依赖的附件，打包成多个文件，结构复杂，启动快。\n -w：没有命令行窗口\n -i：exe文件的图标\n</code></pre>\n<p>(2)多个文件打包</p>\n<ul>\n<li>命令行打包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#RecallInterface.py，Interface.py, f1.py在同一目录下,默认是以-D形式打包</span></span><br><span class=\"line\">pyinstaller RecallInterface.py Interface.py, f1.py</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyinstaller RecallInterface.py -p C:/Interface.py, -p C:/f1.py</span><br></pre></td></tr></table></figure>\n\n<p>注：到切换到主文件路径下执行命令，不然要写RecallInterface.py，Interface.py, f1.py的完整路径。</p>\n<ul>\n<li>pyi-makespec打包<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyi-makespec RecallInterface.py</span><br></pre></td></tr></table></figure>\n修改.spec文件<a href=\"https://pyinstaller.readthedocs.io/en/stable/spec-files.html#\">spec文档</a><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- mode: python ; coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\">block_cipher = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = Analysis([<span class=\"string\">&#x27;RecallInterface.py&#x27;</span>, <span class=\"string\">&#x27;Interface.py&#x27;</span>, <span class=\"string\">&#x27;f1.py&#x27;</span>],</span><br><span class=\"line\">             pathex=[<span class=\"string\">&#x27;C:\\\\pythonProject\\\\crawer&#x27;</span>],</span><br><span class=\"line\">             binaries=[],</span><br><span class=\"line\">             datas=[],</span><br><span class=\"line\">             <span class=\"comment\">#此处可以添加静态资源，例如你有个图片文件夹imgs，可以这样写[(&#x27;imgs&#x27;,&#x27;imgs&#x27;),(&#x27;test.txt&#x27;,&#x27;.&#x27;)]，打包以后会有一个一样的文件夹，点表示当前文件夹。</span></span><br><span class=\"line\">             hiddenimports=[],</span><br><span class=\"line\">             hookspath=[],</span><br><span class=\"line\">             runtime_hooks=[],</span><br><span class=\"line\">             excludes=[],</span><br><span class=\"line\">             win_no_prefer_redirects=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             win_private_assemblies=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             cipher=block_cipher,</span><br><span class=\"line\">             noarchive=<span class=\"literal\">False</span>)</span><br><span class=\"line\">pyz = PYZ(a.pure, a.zipped_data,</span><br><span class=\"line\">             cipher=block_cipher)</span><br><span class=\"line\">exe = EXE(pyz,</span><br><span class=\"line\">          a.scripts,</span><br><span class=\"line\">          a.binaries,</span><br><span class=\"line\">          a.zipfiles,</span><br><span class=\"line\">          a.datas,</span><br><span class=\"line\">          [],</span><br><span class=\"line\">          name=<span class=\"string\">&#x27;RecallInterface&#x27;</span>,</span><br><span class=\"line\">          debug=<span class=\"literal\">False</span>,</span><br><span class=\"line\">          bootloader_ignore_signals=<span class=\"literal\">False</span>,</span><br><span class=\"line\">          strip=<span class=\"literal\">False</span>,</span><br><span class=\"line\">          upx=<span class=\"literal\">True</span>,<span class=\"comment\"># 打包的时候进行压缩，False表示不压缩</span></span><br><span class=\"line\">          upx_exclude=[],<span class=\"comment\"># 是否显示黑窗口，刚开始打包的时候一般都会有问题，建议设为True，解决所有问题后可以设置为False)</span></span><br><span class=\"line\">          runtime_tmpdir=<span class=\"literal\">None</span>,</span><br><span class=\"line\">          console=<span class=\"literal\">True</span> )</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n执行命令<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pyinstaller RecallInterface.spec</span><br></pre></td></tr></table></figure>\n<script src=\"https://utteranc.es/client.js\" repo=\"maryxingguo / blog-commit\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async>\n</script></li>\n</ul>\n","categories":["教程"],"tags":["爬虫"]},{"title":"面向侧信道分析的AES硅前仿真","url":"/2025/09/17/%E9%9D%A2%E5%90%91%E4%BE%A7%E4%BF%A1%E9%81%93%E5%88%86%E6%9E%90%E7%9A%84AES%E7%A1%85%E5%89%8D%E4%BB%BF%E7%9C%9F/","content":"<h1 id=\"1-理论知识\"><a href=\"#1-理论知识\" class=\"headerlink\" title=\"1 理论知识\"></a>1 <strong>理论知识</strong></h1><h2 id=\"1-1-AES算法实现\"><a href=\"#1-1-AES算法实现\" class=\"headerlink\" title=\"1.1 AES算法实现\"></a>1.1 AES算法实现</h2><p>AES算法是目前应用最广泛的对称密码算法之一，在信息安全保护领域发挥着重要作用。该算法主要包含四种操作，分别是轮密钥加(Add Round Key)、字节代换(Sub Byte)、行位移(Shift Rows)和列混合(Mix Column)，其中值得格外关注的是轮密钥加运算将原始的密钥扩展出了10个轮密钥，分别用于10轮运算。经过多年的分析和使用，AES在分组密码算法中占据稳固的地位。</p>\n<p>AES算法实现包含软件和硬件实现。软件实现通过编程语言在CPU、MCU等通用计算核心上运行，借助AES指令集扩展提升效率，具有灵活性强、部署成本低、开发周期短的优势，适用于嵌入式设备等场景多变的通用加密需求。硬件实现则通过ASIC、FPGA等专用电路固化AES逻辑，采用迭代或流水线结构设计，具备吞吐量高、延迟低、资源隔离性好及易实现硬件级侧信道防护的特点，适配安全芯片等高性能、高安全等级的专用场景。<em><strong>*相较于软件实现，基于AES算法的硬件实现存在开发周期长、成本高的问题。*</strong></em></p>\n<p>以AES芯片为例，开发周期包括硅前和硅后阶段。“硅前”指流片前借助EDA工具完成电路设计、仿真、验证等核心工作，以确保设计方案在功能、性能、功耗等方面符合需求且可制造的过程。与之相对，“硅后”指流片完成后对实际制造的物理芯片进行封装、全方位测试以及规模化量产的阶段，此时芯片已具备物理实体。以Alma Technologies公司开发的一款加密芯片Alma AES-P为例，物理制造成本费用主要由掩膜版和晶圆构成，且掩膜版占比大、成本高。因此，在硅前进行密码芯片全面评估至关重要，可提前发现问题以规避高昂的芯片物理制造失败损失。</p>\n<h2 id=\"1-2-侧信道分析\"><a href=\"#1-2-侧信道分析\" class=\"headerlink\" title=\"1.2 侧信道分析\"></a>1.2 侧信道分析</h2><p>密码算法安全性不仅依赖于算法本身的数学理论基础，更依赖于实际部署中的实现安全性。侧信道分析就是利用软件或者硬件实现密码算法执行过程中泄露的物理信息恢复密钥等密密信息。随着深度神经网络应用于侧信道分析领域，攻击时仅需要几条信号即可完成侧信道分析。</p>\n<p>目前，为密码算法添加掩码等防护策略有助于抵抗侧信道分析，但是正确实施掩码防护是一件繁琐、且容易出错的任务。此外，密码算法硬件实现存在开发周期长、成本高的问题。因此，加掩密码算法硬件实现更需要在硅前阶段确保没有侧信道泄露。<em><strong>*在硅前阶段进行泄露定位有助于早期发现泄露并向设计者反馈细节，降低因评估失败导致的芯片重设计与制造成本。*</strong></em></p>\n<p>传统泄露定位方法主要应用在硅后阶段，在硅前阶段研究存在不足。如t-Test需大量功耗轨迹，效率低；DL-SCA对掩码实现威胁大，无需预处理，但硅前阶段针对其的泄漏定位方法尚未深入研究。（基于非侧信道分析的形式验证方法，如REBECCA，依赖SAT solver，规模和时间受限）</p>\n<h2 id=\"1-3-AES硅前仿真原理\"><a href=\"#1-3-AES硅前仿真原理\" class=\"headerlink\" title=\"1.3 AES硅前仿真原理\"></a>1.3 AES硅前仿真原理</h2><p>硅前设计遵循“从抽象到具体”的分层范式，通过构建RTL级行为模型、门级逻辑模型、晶体管级开关模型、版图级集几何模型等层层递进的精准模型，实现从抽象设计意图到物理实体的“无偏差映射”。但这一过程中，“设计是否正确”“物理实现后是否存在风险”无法直接判断，因此硅前仿真成为连接“设计模型”与“实体芯片”的关键桥梁。其核心原理是基于“模型驱动”与“物理规律映射”，通过EDA工具将芯片设计全流程转化为可计算的数字模型，用数学算法提前“预演”实体芯片的电学、逻辑及物理行为，确保设计无偏差落地。</p>\n<p>为适配不同设计阶段的需求，硅前仿真（涵盖功能、时序、功耗等多维度验证目标）呈现“分层递进”的特点。在设计早期，RTL级仿真以Verilog&#x2F;VHDL语言快速验证算法逻辑正确性，初步定位潜在泄露模块。进入中期，门级仿真融入逻辑门延时信息，更贴近电路实际工作状态，不仅可二次确认功能正确性，也可进一步分析逻辑级信息泄露。到了物理实现前，物理级仿真（即晶体管级和版图级设计阶段）进一步整合连线寄生参数，以高精度验证时序性能，同时为分析布局布线引入的物理级信息泄露提供支撑。硅前仿真为芯片“功能正确、性能达标”提供了全流程的前置验证与优化依据。</p>\n<p>以AES加密芯片的功耗仿真为例，AES在运算时的敏感信息（如密钥、中间结果）会通过功耗无意识泄露，其中与敏感信息直接相关的“动态功耗”，正是侧信道分析恢复密钥的突破口。在此场景下，基于设计模型与工艺参数的硅前仿真，能够提前捕捉芯片的功耗特征，为侧信道风险预判提供依据。不过，在依托功耗仿真开展抗侧信道安全评估时，需在模型精度与仿真速度之间进行精准权衡。从RTL到晶体管级的抽象层级递进过程中，每一层级的深入都会揭示更多影响功耗的潜在依赖关系：例如，门级功耗模型可有效捕捉门驱动强度、静态功耗泄漏及IR降效应等关键因素，这些在RTL功耗模型中不可见的因素，却会显著影响数据依赖性功耗。</p>\n<h1 id=\"2-硅前仿真实验报告\"><a href=\"#2-硅前仿真实验报告\" class=\"headerlink\" title=\"2 硅前仿真实验报告\"></a>2 <strong>硅前仿真实验报告</strong></h1><p>采用Synopsys公司的芯片设计流程和32-28纳米工艺的电子设计套件。首先根据设计规范,使用Verilog硬件描述语言编写可综合的<em><strong>*RTL代码*</strong></em>,并对RTL代码进行仿真。然后对RTL代码进行综合，综合后生成的门级网表和RTL代码进行<em><strong>*等效性检验*<em><strong>并</strong></em>*做静态时序分析，*<em><strong>进而实现</strong></em>*门级仿真*<em><strong>。接着进行版图设计,先是根据各逻辑单元间的时序采用时序驱动布局策略来做</strong></em>*物理布局和全局布线*</strong></em>,之后在设计中插入<em><strong>*时钟树*<em><strong>。然后进行详细</strong></em>*布线*</strong></em>,并从详细布线后的版图中提取出****真实的时延值*<em><strong>并将其反标给网表,再作</strong></em>*等效性检验*<em><strong>、</strong></em>*静态时序分析*<em><strong>和</strong></em>*仿真验证****保证满足时序约束。</p>\n<h2 id=\"2-1-实验环境\"><a href=\"#2-1-实验环境\" class=\"headerlink\" title=\"2.1 实验环境\"></a>2.1 实验环境</h2><p>仿真平台：VMware虚拟机，Centos7操作系统，Synopsys系列设计软件（VCS、DC、ICC、FM、PT）</p>\n<p>仿真项目：</p>\n<p><img src=\"wps1.jpg\" alt=\"img\"> </p>\n<h2 id=\"2-2-RTL级\"><a href=\"#2-2-RTL级\" class=\"headerlink\" title=\"2.2 RTL级\"></a>2.2 RTL级</h2><p>目标：用硬件描述语言Verilog实现AES算法，并利用VCS软件实现RTL级仿真。</p>\n<h3 id=\"2-2-1-128位AES加密RTL级-Verilog实现\"><a href=\"#2-2-1-128位AES加密RTL级-Verilog实现\" class=\"headerlink\" title=\"2.2.1 128位AES加密RTL级 Verilog实现\"></a>2.2.1 128位AES加密RTL级 Verilog实现</h3><p><img src=\"wps2.jpg\" alt=\"img\"> </p>\n<p>图1：RTL级 Verilog实现</p>\n<p>aes_ASIC.v是ASIC芯片顶层接口模块，通过标准化的WISHBONE总线接口实现外部设备与AES加密功能的通信。</p>\n<p>aes_top.v是WISHBONE总线对AES加密的控制模块，实现对 AES 加密流程的总线控制。</p>\n<p>aes_cipher_top.v是128位AES加密核心模块，完整实现128位AES加密流程，包括初始化、轮密钥加、字节替换、行移位、列混淆等AES标准算法步骤。</p>\n<p>aes_key_expand_128.v是密钥扩展模块，生成AES加密所需的轮密钥。</p>\n<p>aes_rcon.v是轮常量生成模块，生成轮密钥所需的 8 位轮常量。</p>\n<p>aes_sbox.v是字节替换模块，实现8位输入数据到8位输出数据的非线性映射。</p>\n<p>代码来自Rudolf Usselmann（硬件设计领域工程师，活跃于开源硬件社区）的开源项目（<a href=\"http://www.asics.ws)/\">www.asics.ws）</a></p>\n<h3 id=\"2-2-2-RTL仿真\"><a href=\"#2-2-2-RTL仿真\" class=\"headerlink\" title=\"2.2.2 RTL仿真\"></a>2.2.2 RTL仿真</h3><p>命令行：.&#x2F;run_vcs</p>\n<p>功能：利用VCS软件编译所有文件并生成仿真可执行文件，最终输出AES加密的仿真结果。</p>\n<p><img src=\"wps3.jpg\" alt=\"img\"> </p>\n<p>所需材料：激励文件、RTL级 Verilog实现、AED 32nm工艺库I&#x2F;O接口模块。</p>\n<h2 id=\"2-3-门级\"><a href=\"#2-3-门级\" class=\"headerlink\" title=\"2.3 门级\"></a>2.3 门级</h2><p>目标：通过DC综合软件将RTL代码转化为和工艺库对应的门级网表，并利用VCS软件实现门级仿真。</p>\n<p>输入：RTL代码、工艺库</p>\n<p>输出：网表(Netlist)、值变存储文件（VCD）、时序约束文件（SDC）、功耗文件</p>\n<h3 id=\"2-3-1-综合\"><a href=\"#2-3-1-综合\" class=\"headerlink\" title=\"2.3.1 综合\"></a>2.3.1 综合</h3><p>（1）RTL预处理</p>\n<p>命令行：run_dc_read_rtl.sh</p>\n<p>功能：初始化工作目录、配置综合参数，并调用DC软件执行RTL代码读取流程。</p>\n<p><img src=\"wps4.jpg\" alt=\"img\"> </p>\n<p>（2）综合</p>\n<p>命令行：run_dc_constraint_compile.sh</p>\n<p>功能：初始化工作目录、配置综合优化参数，并调用DC软件执行执行“时序约束+综合优化”流程。</p>\n<p><img src=\"wps5.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-3-2-等效性检验\"><a href=\"#2-3-2-等效性检验\" class=\"headerlink\" title=\"2.3.2 *等效性检验*\"></a><strong>2.3.2</strong> <em><strong>*等效性检验*</strong></em></h3><p>命令行：run_fm.scr</p>\n<p>功能：利用FM软件将RTL和网表进行功能对比，检查门级网表的正确性。</p>\n<p><img src=\"wps6.jpg\" alt=\"img\"> </p>\n<p><img src=\"wps7.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-3-3-门级仿真\"><a href=\"#2-3-3-门级仿真\" class=\"headerlink\" title=\"2.3.3 门级仿真\"></a>2.3.3 门级仿真</h3><p>代码行：.&#x2F;run_vcs</p>\n<p>功能：基于实际的逻辑门网表和时序信息进行门级仿真。</p>\n<p><img src=\"wps8.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-3-4-门级功耗仿真\"><a href=\"#2-3-4-门级功耗仿真\" class=\"headerlink\" title=\"2.3.4 门级功耗仿真\"></a>2.3.4 门级功耗仿真</h3><p>把门级生成的VCD文件和工艺库放入Primepower中，计算出一条条对应着明文的瞬时功耗曲线AES1.out。使用Primepower计算一条功耗的过程如下：</p>\n<p>1）set search_path “&#x2F;home&#x2F;…&#x2F;project&#x2F;AES” &#x2F;&#x2F; 设置源文件和工艺库文件所在目录</p>\n<p>2）set link_path “* slow.db fast.db dw_foundation.sldb” &#x2F;&#x2F;指定工艺库文件</p>\n<p>3）read_verilog &#x2F;home&#x2F;…&#x2F;project&#x2F;AES&#x2F;AES_NETLIST.v &#x2F;&#x2F;读入网表文件</p>\n<p>4）current_design AES &#x2F;&#x2F; 指定编译芯片的主模块名</p>\n<p>5）read_vcd -strip_path AES_TB&#x2F;AES AES1.VCD &#x2F;&#x2F;读入VCD文件</p>\n<p>6）set_waveform -file &#x2F;home&#x2F;…&#x2F;project&#x2F;AES&#x2F;AES1.out-format out&#x2F;&#x2F;指定功耗输出路径</p>\n<p>7）calculate_power -waveform &#x2F;&#x2F; 根据网表和“值变存储文件”VCD计算功耗</p>\n<h2 id=\"2-4-晶体管级和版图级\"><a href=\"#2-4-晶体管级和版图级\" class=\"headerlink\" title=\"2.4 晶体管级和版图级\"></a>2.4 晶体管级和版图级</h2><p>目的：利用ICC软件将门级网表（仅包含逻辑单元连接关系）转化为符合工艺规则、满足时序&#x2F;功耗&#x2F;面积（PPA）要求的“物理版图”（包含单元位置、金属布线、电源网络等物理信息），并利用VCS实现物理级仿真。</p>\n<p>输入：门级网表、工艺库、器件库、时序约束文件</p>\n<p>输出：版图、布局布线网表</p>\n<h3 id=\"2-4-1-ICC软件使用\"><a href=\"#2-4-1-ICC软件使用\" class=\"headerlink\" title=\"2.4.1 ICC软件使用\"></a>2.4.1 ICC软件使用</h3><p>（1）文件准备</p>\n<p>命令行：</p>\n<p>chmod +x .&#x2F;prep_sdc.sh </p>\n<p>.&#x2F;prep_sdc.sh aes_ASIC.sdc</p>\n<p>功能：将 DC软件生成的SDC时序约束文件转换为适合ICC软件的格式。</p>\n<p><img src=\"wps9.jpg\" alt=\"img\"> </p>\n<p>（2）启动ICC工具</p>\n<p>命令行：</p>\n<p>icc_shell</p>\n<p>gui_start</p>\n<p>功能：启动ICC软件的命令行交互界面。</p>\n<p><img src=\"wps10.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-2-布局布线前期设置\"><a href=\"#2-4-2-布局布线前期设置\" class=\"headerlink\" title=\"2.4.2 布局布线前期设置\"></a>2.4.2 布局布线前期设置</h3><p>命令行：source .&#x2F;scripts&#x2F;1_design_setup.tcl</p>\n<p>功能：创建设计库、导入网表和约束、配置工艺库和电源地网络，为后续的布局规划、时钟树综合、布线等步骤建立完整的设计环境，确保工具能正确识别设计数据和物理规则。</p>\n<p><img src=\"wps11.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-3-布局规划\"><a href=\"#2-4-3-布局规划\" class=\"headerlink\" title=\"2.4.3 布局规划\"></a>2.4.3 布局规划</h3><p>命令行：source .&#x2F;scripts&#x2F;2_floorplan.tcl</p>\n<p>功能：定义芯片边界、放置单元、构建电源网络、优化布局和全局布线，为后续的时钟树综合（CTS）和详细布线奠定基础。</p>\n<p><img src=\"wps12.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-4-布局优化\"><a href=\"#2-4-4-布局优化\" class=\"headerlink\" title=\"2.4.4 布局优化\"></a>2.4.4 布局优化</h3><p>命令行：source .&#x2F;scripts&#x2F;3_placement.tcl</p>\n<p>功能：实现单元精细放置优化、低功耗配置、时钟树规则定义，为后续时钟树综合（CTS）奠定基础。</p>\n<p><img src=\"wps13.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-5-时钟树综合\"><a href=\"#2-4-5-时钟树综合\" class=\"headerlink\" title=\"2.4.5 时钟树综合\"></a>2.4.5 时钟树综合</h3><p>命令行：source .&#x2F;scripts&#x2F;4_cts.tcl</p>\n<p>功能：构建时钟树、配置CTS参数、优化时钟路径、执行物理布线，为后续信号布线和时序收敛奠定基础。</p>\n<p><img src=\"wps14.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-6-布线及其优化\"><a href=\"#2-4-6-布线及其优化\" class=\"headerlink\" title=\"2.4.6 布线及其优化\"></a>2.4.6 布线及其优化</h3><p>命令行：source .&#x2F;scripts&#x2F;5_route.tcl</p>\n<p>功能：完成从时钟布线到信号布线的全流程，并确保布线结果符合物理规则和时序要求。</p>\n<p><img src=\"wps15.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-7-版图\"><a href=\"#2-4-7-版图\" class=\"headerlink\" title=\"2.4.7 版图\"></a>2.4.7 版图</h3><p>命令行：source .&#x2F;scripts&#x2F;6_chip_finishing.tcl</p>\n<p>功能：将布线完成的设计打磨为符合流片要求的最终版本，并输出仿真网表、LVS网表、寄生参数、物理版图等文件。</p>\n<p><img src=\"wps16.jpg\" alt=\"img\"> </p>\n<p><img src=\"wps17.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-8-时序分析\"><a href=\"#2-4-8-时序分析\" class=\"headerlink\" title=\"2.4.8 时序分析\"></a>2.4.8 时序分析</h3><p>命令行：</p>\n<p>chmod +x run_pt.sh</p>\n<p>run_pt.sh</p>\n<p>功能：实现时序分析。</p>\n<p><img src=\"wps18.jpg\" alt=\"img\"> </p>\n<p><img src=\"wps19.jpg\" alt=\"img\"> </p>\n<h3 id=\"1-1-1-等效性检验\"><a href=\"#1-1-1-等效性检验\" class=\"headerlink\" title=\"1.1.1 *等效性检验*\"></a><strong>1.1.1</strong> <em><strong>*等效性检验*</strong></em></h3><p>命令行：run_fm.scr</p>\n<p>功能：利用FM软件验证版图之后的网表和综合后的网表功能是否等价。</p>\n<p><img src=\"wps20.jpg\" alt=\"img\"> </p>\n<p><img src=\"wps21.jpg\" alt=\"img\"> </p>\n<h3 id=\"2-4-9-物理级仿真\"><a href=\"#2-4-9-物理级仿真\" class=\"headerlink\" title=\"2.4.9 物理级仿真\"></a>2.4.9 物理级仿真</h3><p>命令行：.&#x2F;run_vcs</p>\n<p>功能：实现物理级仿真</p>\n<p><img src=\"wps22.jpg\" alt=\"img\"> </p>\n<h2 id=\"2-5-其他\"><a href=\"#2-5-其他\" class=\"headerlink\" title=\"2.5 其他\"></a>2.5 其他</h2><h3 id=\"2-5-1-数字IC后端设计各阶段网表特性与用途\"><a href=\"#2-5-1-数字IC后端设计各阶段网表特性与用途\" class=\"headerlink\" title=\"2.5.1 数字IC后端设计各阶段网表特性与用途\"></a>2.5.1 数字IC后端设计各阶段网表特性与用途</h3><p>RTL综合后网表：作为前端逻辑到后端物理实现的过渡载体，仅包含核心逻辑信息，具体包括标准单元（如与门、触发器等）的实例化关系、模块间的端口连接逻辑，以及完整的设计层次结构。该网表不涉及任何物理位置延迟信息，只有门延迟（标准单元库的固有延迟参数），仅用于明确“用哪些逻辑单元实现设计功能”，是后续布局布线的基础输入。</p>\n<p>布局后网表：在RTL综合网表基础上，融入初步物理信息并聚焦时序相关性。其内容包含：核心逻辑单元（门电路、触发器等）及互连关系；基于单元物理摆放位置估算的互连寄生参数（RC延迟）；单元的具体物理坐标，以及完整的电源地（VDD&#x2F;VSS）网络。该网表涉及门延迟和互连延迟，核心用途是支持布局后时序仿真与分析，通过近似RC延迟初步验证时序性能，确保后续布线优化有明确方向，同时为物理实现的合理性提供早期评估依据。</p>\n<p>布线后网表：作为物理实现的最终网表，完整保留与逻辑功能、物理连接相关的所有元素，具体包括：二极管、电源地端口、布线过程中产生的寄生元件（如寄生电阻、电容）；设计的层次化结构（或按需扁平化），以及所有物理端口的精确连接关系。其核心用途是支撑“版图-网表一致性检查（LVS）”，通过与实际版图的物理连接比对，确保布线无开路、短路等错误，同时为流片前的最终时序验证、设计规则检查（DRC）提供精准的物理数据支撑。</p>\n<h3 id=\"2-5-2-功耗仿真精度和速度\"><a href=\"#2-5-2-功耗仿真精度和速度\" class=\"headerlink\" title=\"2.5.2 功耗仿真精度和速度\"></a>2.5.2 功耗仿真精度和速度</h3><table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>依赖文件</th>\n<th>功耗精度</th>\n<th>仿真速度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RTL级</td>\n<td>RTL代码+VCD波形</td>\n<td>低（±30%~50%）</td>\n<td>快</td>\n</tr>\n<tr>\n<td>门级</td>\n<td>门级网表+SDF文件</td>\n<td>中（±10%~30%）</td>\n<td>中</td>\n</tr>\n<tr>\n<td>物理级</td>\n<td>布局布线后网表+SPEF</td>\n<td>高（±5%~10%）</td>\n<td>慢</td>\n</tr>\n</tbody></table>\n<p>RTL级估算的功耗精度较低，因为依赖“虚拟门级模型”而非实际物理实现。不能直接计算功耗时，而是通过生成VCD文件提供信号翻转率数据，初步功耗估算。与RTL级的“初步估算”不同，门级仿真基于实际的逻辑门网表和时序信息，基于“实际门级网表+标准单元功耗模型+真实信号翻转波形”计算动态和静态功耗，能更贴近芯片的真实功耗表现。误差主要来源于标准单元库的功耗模型，它是基于典型工艺角的统计值，与实际芯片的工艺偏差存在差异。物理级功耗仿真是基于芯片物理实现的真实结构和参数（如布局布线后的版图、器件物理参数、互连寄生参数等），完全贴合真实芯片的硬件结构，能够提供接近实际芯片工作时的功耗数据。物理级功耗仿真的误差是模型简化、输入不完整、工具算法限制和制造偏差共同作用的结果。</p>\n","categories":["教程"],"tags":["侧信道分析","硅前仿真","AES"]}]